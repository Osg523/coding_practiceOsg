
# 파이썬 정리 노트

## 1) 문자열 합치기
```python
max(int(str(a)+str(b)), int(str(b)+str(a)))  # 예전 방식
# ↓ f-string + max를 먼저
int(max(f"{a}{b}", f"{b}{a}"))
````

---

## 2) `or` 연산자 활용

```python
[] or [-1]      # [-1]
[3, 5] or [-1]  # [3, 5]
```

---

## 3) `"".join(i for i in 문자열)`

```python
"".join(i for i in s)
```

---

## 4) `sort()`와 `sorted()` 차이점

1. **원본 변경 여부**: `sort()`는 리스트 원본을 직접 정렬, `sorted()`는 원본 유지 + 정렬 결과 생성
2. **반환값**: `sort()`는 `None` 반환(제자리 정렬), `sorted()`는 정렬된 새 리스트 반환
3. **사용 대상**: `sort()`는 `list` 전용 메서드, `sorted()`는 모든 iterable(리스트/튜플/문자열/set/dict 등)에 사용 가능

---

## 5) `endswith()`에 대하여

1. **기본 구조**

```python
문자열.endswith(접미사)
```

2. **튜플로 여러 접미사 검사**

```python
"photo.jpeg".endswith((".jpg", ".jpeg", ".png"))  # True
```

3. **특정 구간만 잘라서 검사**

```python
s = "abc_def_ghi"
s.endswith("def", 0, 7)  # True  (s[0:7] == "abc_def")
```

---

## 6) `translate()`, `maketrans()`

* `str.maketrans(...)`: 변환표(매핑 테이블) 만들기
* `myString.translate(table)`: 표대로 변환/삭제 실행

```python
table = str.maketrans("abc", "123")
"abc cab".translate(table)  # '123 312'
```

---

## 7) 한 줄 코드에서 `if` 위치 차이

`if`는 두 종류로 쓰입니다.

1. **필터용 if** (조건이 참인 것만 걸러내기) → `if`만 쓰는 경우 → 보통 `for` 뒤

```python
[i for i in arr if i % 2 == 0]
```

2. **삼항연산자 if** (조건에 따라 값 바꾸기) → `if else`가 함께 등장

```python
["짝" if i % 2 == 0 else "홀" for i in arr]
```

---

## 8) `eval()`

`eval()`은 문자열로 된 파이썬 **표현식(expression)** 을 실제 코드처럼 평가해 결과를 반환합니다.

```python
eval("1 + 2 * 3")  # 7
```

---

## 9) `find()`의 두 번째 인자

```python
s.find(찾고_싶은_값, 시작_인덱스)
```

---

## 10) `str()`과 리스트

```python
str([7, 77, 17])           # "[7, 77, 17]"
str([7, 77, 17]).count('7')  # 3

list(map(str, [1, 2, 3, 4, 5]))  # ['1','2','3','4','5']
```

---

## 11) `bin()`, `int()`로 2진수 덧셈

```python
bin(int(bin1, 2) + int(bin2, 2))[2:]
```

## 12) index() 활용 방법
### 핵심 원리
`list.index(값)` 함수는 리스트에 중복된 값이 있어도 **가장 먼저 나오는 인덱스**만 반환합니다.

### 작동 메커니즘
1. **정렬**: `[100, 100, 80]` (인덱스: 0, 1, 2)
2. **동점자**: 100점을 찾으면 항상 **0**을 반환 → 둘 다 **1등**
3. **다음 점수**: 80점은 인덱스 **2**에 있음 → **3등** (2등 건너뜀)

### 최종 코드
```python
def solution(score):
    # 합계 기준 내림차순 정렬
    rank = sorted([sum(i) for i in score], reverse=True)
    # 인덱스(0부터 시작) + 1 = 등수
    return [rank.index(sum(i)) + 1 for i in score]
```

## 13) 문자열 밀기, feat) find()
네, 이 테크닉은 코딩 테스트에서 문자열 처리 문제를 만났을 때 **시간과 코드를 획기적으로 줄여주는 중요한 패턴**입니다. 다음과 같이 '배운 점'으로 정리해 두시면 좋습니다.

### 📝 [배운 점] 문자열 회전 문제의 핵심 치트키: `S + S`

**1. 핵심 원리**

* "문자열을 회전시킨다"는 것은 끝과 처음이 연결된 **순환 구조**를 의미합니다.
* 문자열 `B`를 두 번 이어 붙이면(`B + B`), 그 안에는 `B`를 회전시켜 만들 수 있는 **모든 경우의 수가 순서대로 포함**되어 있습니다.

**2. 사고의 전환 (Simulation → Pattern Matching)**

* **기존 방식 (Simulation):** `for`나 `while` 문을 돌며 직접 문자를 자르고 붙여서 비교함. (구현이 복잡하고 인덱스 실수가 잦음)
* **개선 방식 (Pattern Matching):** `B + B`라는 긴 문자열 안에 `A`가 포함되어 있는지(`find`) 검사함. (단순 포함 여부 문제로 바뀜)

**3. 코드 적용**

```python
# A: 원본, B: 회전된 문자열
# B를 2번 반복한 문자열에서 A를 찾으면, 시작 인덱스가 곧 민 횟수가 된다.
return (B * 2).find(A)

```

**4. 주의할 점**

* 이 방식은 `A`와 `B`의 **길이가 같을 때만** 유효합니다. (길이가 다르면 회전으로 만들 수조차 없으므로 미리 예외 처리 필요)

이 `S + S` 패턴은 파이썬뿐만 아니라 다른 언어에서도 동일하게 적용되는 알고리즘 팁이니 꼭 기억해 두세요!

**다음 단계로, 이 `find` 함수가 반환하는 '인덱스'가 왜 정확히 '민 횟수'와 일치하는지 논리적으로 이해가 되시나요?** 필요하시면 이 부분도 설명해 드릴 수 있습니다.


## 14) xor 비트 연산자
mode = 0
mode ^= 1 # 같으면 0 다르면 1


## 15) 특이한 정렬, 프로그래머스 0단계에서 배운점
### 💡 핵심 아이디어
**1. 튜플을 이용한 '계급장' (다중 정렬)**
* `(1순위, 2순위)`로 묶어서 리턴하면, **1순위가 동점일 때만 2순위를 비교**합니다.
* 복잡한 `if`문 없이 우선순위를 한 번에 정할 수 있습니다.

**2. 뺄셈을 이용한 '순서 뒤집기' (역발상)**
* `sorted`는 기본적으로 **작은 수**를 좋아합니다 (오름차순).
* **큰 수**를 앞으로 보내고 싶다면?
    * 값에 마이너스(`-x` 또는 `n-x`)를 붙여서 **일부러 작게 만들어** 앞으로 오게 속이는 기법입니다.


## 16) 겹치는 선분 길이 구하기 핵심 요약
### 1. 문제 해결 논리 (집합 활용)
단순 덧셈은 세 선분이 모두 겹칠 때 **중복 계산(Double Counting)** 오류가 발생하므로 **집합(Set)**을 사용해야 합니다.

1.  **변환 (`range`)**: 선분 `[start, end]`를 `set(range(start, end))`로 변환 (구간 1단위화)
2.  **교집합 (`&`)**: 두 선분씩 짝지어 겹치는 구간 추출 (`AB`, `AC`, `BC`)
3.  **합집합 (`|`)**: 구해둔 교집합들을 하나로 합쳐 중복 제거
4.  **결과**: 최종 집합의 `len()` 반환

### 2. 주요 Python 문법
#### 집합 연산
* `&`: 교집합 (겹치는 것)
* `|`: 합집합 (더하되 중복은 제거)

#### sum() 함수 주의사항
* `sum()`은 리스트 같은 반복 가능한 객체 하나만 받습니다.
* ❌ `sum(10, 20, 30)` -> TypeError
* ✅ `sum([10, 20, 30])` -> OK

### 3. 최종 코드 패턴
```python
def solution(lines):
    # 1. 선분을 집합으로 변환
    sets = [set(range(min(l), max(l))) for l in lines]
    
    # 2. 교집합 구하기
    a = sets[0] & sets[1]
    b = sets[0] & sets[2]
    c = sets[1] & sets[2]
    
    # 3. 합집합 후 길이 반환 (중복 방지)
    return len(a | b | c)
```


## 17) 조건식 활용법
1.  min(bill) > min(wallet) or max(bill) > max(wallet) [프로그래머스 1단계 문제 중](https://school.programmers.co.kr/learn/courses/30/lessons/340199)


## 18) 약수의 개수가 짝수인지 홀수인지
- 완전제곱수만 약수의 개수가 홀수이다.
